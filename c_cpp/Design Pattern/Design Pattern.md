# 面向对象设计模式(总述)

---
## 概述
* 设计模式是对软件设计中普遍存在的各种问题所提出的解决方案.
> 设计模式能使不稳定依赖于相对稳定, 具体依赖于相对抽象, 避免会引起麻烦的紧耦合, 以增强软件设计面对并适应变化的能力. 


---
## 设计框架


---
## [设计原则]( http://blog.csdn.net/u010355144/article/details/44940171 )
### 1. 开放封闭原则
* 对扩展开放: 
有新的需求时, 可以对现有代码进行扩展, 以适应新的情况
* 对修改封闭: 
一旦类设计完成就可以独立完成其工作, 而不要对其进行任何尝试的修改

### 2. 里氏转换原则
子类要能够替换基类, (只有这样才能保证系统在运行期间识别子类)

### 3. 依赖倒转原则
高层模块不依赖于底层模块, 二者都同依赖于抽象

### 4. 组合/聚合原则
要尽量使用合成/聚合达到复用, 而不是继承关系达到复用的目的.

#### 5. 接口隔离原则
应当为客户端提供尽可能小的单独的接口, 而不是提供大的总的接口

#### 6. “迪米特”法则
又叫最少知识原则, 一个软件实体应当尽可能少的与其他实体发生相互作用, 使得系统模块功能相对独立

#### 7. 单一职责原则
每一个类应该专注于做一件事情, 保证实体只有一个引起它变化的原因



---
## 基本模式

### [创建型模式]( https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F )

#### 1. [抽象工厂模式(Abstract factory pattern)]( https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82 )
![](./img/Abstract_factory_UML.svg)

##### 定义
提供接口, 创建一系列`相关`或`独立`的`对象`, 而不指定这些对象的具体`类`. 

##### 使用
先实例化抽象工厂, 然后用抽象工厂提供的接口来创建对象, 并且接口只返回所创建对象的`抽象引用`(或指针).

##### 适用性
* 一个系统要独立于它的产品的创建、组合和表示时。
* 一个系统要由多个产品系列中的一个来配置时。
* 需要强调一系列相关的产品对象的设计以便进行联合使用时。
* 提供一个产品类库，而只想显示它们的接口而不是实现时。


##### 优缺点
* 优点
  1. 具体产品从客户端代码中分离出来
  2. 容易改变产品的系列
  3. 将一个系列的产品族统一到一起创建

* 缺点
  1. 在产品族中扩展新的产品很困难, 需要修改抽象工厂的接口


#### 1. [工厂方法模式(Factory method pattern)]( https://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95 )

##### 定义
定义一个创建对象的接口, 但让实现这个接口的类(子类)来决定实例化哪个类, 将类的实例化推迟到子类中进行. 


#### 1. [生成器模式]( https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F#C.2B.2B )

> 将复杂对象的`建造过程`抽象出来(抽象类别), 使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象

##### 适用性
* 当创建对象的算法应该独立于该对象的组成部分以及它们的装配方式时
* 当构造过程必须允许构造的对象有不同的表示时


#### 1. [单例模式(Singleton)]( http://www.jellythink.com/archives/82 )

* 只能有一个实例存在. 

##### 应用场景
在某个服务器程序中,将配置信息存放在一个文件中, 而配置数据由一个单例对象统一读取, 然后服务进程中的其他对象再通过这个单例对象获取配置信息. 这样就简化了复杂环境下的配置管理. 

##### 实现思路
* 将构造函数声明为私有
* 用一个私有的静态指针变量指向类的唯一实例, 并用一个公有静态方法获取该实例. 


#### 1. [对象池模式(Object Pool Pattern)]( https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%A8%A1%E5%BC%8F )
* 对象池包含已经初始化且可使用的对象, 可以在有需求是创建和销毁对象. 对象池的用户可以从池子中获取对象进行操作, 并在不需要时归还给对象池而非直接销毁. 
* 如: 线程池, 数据库连接池

##### 应用场景
对于初始化,实例化的代价高, 且需要经常实例化而每次实例化的数量较少的情况, 使用对象池可以显著提高性能. 因为从对象池中获取对象的时间是可预测的, 而新建一份实例的时间是不确定的. 


##### 1 [原型模式(Prototype)]( https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F )
* 复制一个已经存在的实例来返回新的实例(被复制的实例称为`原型`), 而不是新建实例. (拷贝构造函数) 
* 多用于创建复杂的或耗时的实例, 在这种情况下, 复制一个已经存在的实例使程序的运行效率更高. 




### 结构型模式

#### 1. [适配器模式(adapter pattern)]( https://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F )
* 将某个类的接口转换成客户端期望的另一个接口表示. 适配器模式可以消由于接口不匹配所造成的类的兼容性问题. 
* 将类自己的接口包裹在一个已存在的类中. 

##### 使用场景
* 想使用一个已经存在的类, 但是它的接口与当前的实际要求不一致. 
* 调用者和功能提供者双方都不太容易修改


#### 1. [修饰模式(Decorator)]( https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F )
* 一种动态的往一个类中添加新行为的设计模式, 在运行时扩充一个类的功能. 
* 修饰模式是类继承的另一种选择. 类继承是在编译时增加行为, 而修饰模式则是在运行时增加行为.

##### 实现方式
* 用一个修饰类包裹原来的类, 将原来的对象作为修饰类构造函数的参数. 
* 修饰类必须和原来的类有相同的接口. 

##### 应用场景
一个对象的属性或方法按照某组规则或几个并行规则(不同用户证书等)需要限制访问时，在这种情况下，不是在原始对象中实现访问控制而是在他的使用中不变或不知道任何限制，并且他被包装在一个访问控制修饰对象中，这个对象能够对允许的原始对象的接口子集服务。


#### 1. [桥接模式(Bridge)]( https://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F )
* 把事物对象和其具体行为, 具体特征分离开, 使它们可以独立的变化. 
> 如"圆形","三角形"归于抽象的形状之下, 而"画圆","画三角形"归于实现行为的"画图"类之下, 然后由"形状"调用"画图". 


#### 1. [外观模式(Facade)]( https://yq.aliyun.com/articles/119762#%E7%AE%80%E8%BF%B0 )
* 为子系统中的一组接口提供一个统一的高层接口, 使得子系统更容易使用. 
* 将子系统的复杂逻辑进行封装, 对外提供一个简单的接口

##### 优点
* 对客户端屏蔽子系统组件, 减少了客户端处理的对象数目, 使得子系统更容易使用. 
* 降低了客户端和子系统的耦合性.

##### 不足
* 不能很好的限制客户端对子系统的访问, 如果访问对子系统做太多的限制, 则会降低客户端的灵活性和可变性. 



### 行为型模式

#### 观察者模式
* 定义一种一对多的依赖关系, 让多个观察者同时监听一个主题对象, 当这个主题对象的状态发生变化时, 通知所有观察者使他们自动更新自己. 

##### 适用场景
1. 一个抽象模型有两个方面, 其中一个方面依赖于另一个方面. 将这二者封装在独立的对象中可以使他们可以各自独立的改变和复用. 
2. 当一个对象的改变需要同时改变其他对象, 而不知道具体有多少对象待改变. 
3. 当一个对象必须通知其他对象,而又不能假定其他对象是谁; 即将目标具体观察者解耦. 


#### [访问者模式]( http://www.jb51.net/article/55999.htm )
* 将更新封装到一个类中, 并由待更改类提供一个接收接口. 
* 在不破坏类的前提下, 为类提供增加新的操作. 
* 双分派

##### 优缺点
###### 优点
* 增加新的操作很容易
* 将有关的行为集中到一个访问者中, 而不是分散到一个个的节点类中
* 积累状态. 每个单独的访问者对象都集中了相关行为, 也就可以在访问的过程中将执行操作的的状态积累在自己内部, 而不是分散到很多节点对象中. 

###### 不足
* 增加新的节点类很困难
* 破坏封装性. 所有结点必须暴露一些在即的操作和内部状态以便访问者进行操作. 


#### [迭代器模式]( http://blog.csdn.net/vipygd/article/details/18746867 )
* 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露该对象的内部表示. 
* 将容器的内部结构与它的遍历解耦. 

##### 作用
* 访问一个聚合对象而无需暴露其内部表示
* 可以支持以不同的方式访问一个聚合(从前往后,从后往前)
* 简化了聚合的接口, 有了迭代器就不需要实现类似的遍历接口
* 每个迭代器保持自己的遍历状态, 因此可以同一个聚合上进行多个遍历



### 并发型模式
......



https://zh.wikipedia.org/zh-cn/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F#.E8.A1.A8.E8.BF.B0.E6.A0.BC.E5.BC.8F
https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549#2
http://blog.csdn.net/column/details/pattern.html?&page=1 




