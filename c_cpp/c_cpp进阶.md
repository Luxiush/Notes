## c++ 内存管理
### 5个内存区
* 栈: 
  存储局部变量，自动释放，效率高，容量有限
  向`下`生长（向着内存地址`减小`的方向生长）

* 堆: 
  由new分配，要手动delete，效率较低（频繁new/delete会造成内存空间碎片化），容量较大，
  向`上`生长

* 自由存储区: 
  由malloc分配，手动free

* 全局/静态存储区


* 常量存储区: 
  存放常量，不允许修改

### malloc/free 和 new/delete 
* malloc/free 是c/c++的标准`库函数`
* new/delete 是c++`运算符`
  ​	

  ## 指针&引用	
### 相同点：
* 都是地址的概念。指针指向一块内存，指针保存的是所指向内存的地址；引用是某块内存的别名

### 区别：
1. 指针是一个实体；而引用只是一个别名。
2. 指针可变，可以再指向其他内存；而引用只能在定义时初始化一次，之后不可变。
3. 指针可以为空，引用不可以.
4. 指针有const，const指针不再可变，引用没有const。（似乎可以说引用是加了const的指针）
5. sizeof指针得到的是指针本身的大小，sizeof引用得到的是所指向对象的大小。

### 指针的指针&指针的引用
* 一个意思，都是为了在将指针作为参数传递时候能够在函数内修改指针的指向。

### const
##### 常量引用
内容不能被修改
```
const int& ref = a;  
ref = b; // 非法
```

##### 常量指针
指针的`指向`可以被修改，但是不能修改指向的`内容`
```
const int* ptr = &a;  
*ptr = b; // 非法, 
ptr = &b; // 合法
```

###### 指针常量
`指向`不能修改，但指向的`内容`可以修改
```
int* const ptr = &a; 
*ptr = b; //合法, 
ptr = &b; //非法
```

##### 常量指针常量
`指向`和`内容`都不能修改
```
const int* const ptr = &a; 
```

### 函数指针
......


## i++ & ++i
* ++i 比 i++ 更“好”，因为i++要保存原来的i值，而保存下来的值却又被立马丢弃。
```
i++:				
	temp = i;							
	i = i+ 1;			
	return temp; 

++i: 
	i = i + 1;
	return i;
```


## c++静态成员的初始化
```
class A{
	const static int a = 0;		//const 静态成员可以直接初始化
	static int a2;			//非const 静态成员在类的声明外初始化
};
int A::a2 = 0;
```

## sizeof 
* 结构体的**总大小**,也就是sizeof的结果,必须是其内部最大成员的`最宽基本类型成员`的整数倍,不足的要补齐	

## [include 预编译]( http://ticktick.blog.51cto.com/823160/596179/ ) 

