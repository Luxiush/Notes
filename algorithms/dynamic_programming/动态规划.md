# [动态规划](http://blog.jobbole.com/83949/)
  ## 基本思想
    -- 将待求解的问题分解为若干个子问题（阶段），
       后一子问题根据前一子问题求解，
       在求解每个子问题时，列出所有可能的局部解，但只保留最优的，
       最后一个子问题的解就是初始问题的解。
    
    -- 思路：自顶向下;  实现：自底向上
       代码版本：自顶向下递归--> 带备忘递归--> 自底向上
        
       
  ## 适用条件
    1* 最优化原理
      -- 问题的最优解所包含的子问题的解也是最优的。
    2* 无后效性
      -- 某状态以后的过程不会影响以前的状态  
    3* 有重叠子问题
      -- 一个子问题在下一阶段的决策中可能被多次适用
      
  ## 基本步骤
    *  初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
    
    1* 分析最优解的性质，并刻画其结构特征
    2* 递归的定义最优解
    3* 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
    4* 根据计算最优值时得到的信息，构造问题的最优解
        
  ## 实现说明
    * 三个要素
      -- 问题的阶段、每个阶段的状态、相邻阶段之间的递推关系  
    * 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，
      最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，
      表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），
      填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，
      最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。  
    
    * 发现递推式：*不妨先手动填写几次表格，在表格中找规律*
      
  ## 常见问题
    * 最长公共子序列
    * 最长递增子序列
    * 0-1背包
        *子结构：给定一个物品i，比较 选择i形成的子问题的最优解 与 不选择i的子问题的最优解。
    * 最短路径
    * 找零
      
      
      
      
      
      
      
      